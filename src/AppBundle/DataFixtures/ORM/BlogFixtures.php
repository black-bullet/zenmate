<?php

namespace AppBundle\DataFixtures\ORM;

use Doctrine\Common\DataFixtures\AbstractFixture;
use Doctrine\Common\DataFixtures\OrderedFixtureInterface;
use Doctrine\Common\Persistence\ObjectManager;
use AppBundle\Entity\Blog;

class BlogFixtures extends AbstractFixture implements OrderedFixtureInterface
{
    public function load(ObjectManager $manager)
    {
        $blog1 = new Blog();
        $blog1->setTitle('GulpJS — фантастически быстрый сборщик проектов');
        $blog1->setBlog('Gulp.js это потоковый сборщик проектов на JS. Он использует Stream и действительно является очень быстрым. Для примера у меня есть проект где около тысячи stylus файлов, GruntJS нужно примерно 2.5 секунды на сборку и 2 секунды на обработку autoprefixerом. Gulp все это делает за 0.5 секунды выигрывая у GruntJS минимум в 4 раза.
            Вас может отпугнуть молодость проекта, отсутствие плагинов и небольшое сообщество. Но это не так, на данный момент ведется активная разработка проекта, написано достаточное количество плагинов под задачи для популярных инструментов. На данный момент существует 165 плагинов, посмотреть их вы можете тут.
            В этой статье будет больше практики, мы соберем среду разработки фронтенда используя Jade и Stylus, запустим локальный сервер и подключим Livereload. Проект я выложил на Github, экспериментируйте. ');
        $blog1->setImage('one.jpg');
        $blog1->setAuthor('Петоро Кучер');
        $blog1->setTags('blog, html, css, js, gulpJS');
        $manager->persist($blog1);

        $blog2 = new Blog();
        $blog2->setTitle('Самые простые техники адаптивной верстки');
        $blog2->setBlog("Википедия говорит:
            «Адаптивный веб-дизайн (англ. Responsive web design) — дизайн веб-страниц, обеспечивающий отличное отображение сайта на различных устройствах, подключённых к интернету.»
            Благодаря адаптивной верстке сайт будет качественно и удобно отображаться на разных устройствах, таких как:
            персональные компьютеры
            ноутбуки
            планшеты
            смартфоны и других.
            С каждым днем адаптивная верстка становится все популярней. Адаптивных сайтов появляется все больше и больше.
            Для начала освоения адаптивной верстки мы попробуем сделать простенькую фотогалерею, которая будет хорошо отображаться на различных экранах устройств.
            Смысл адаптивного макета в том, что сайт динамически (в режиме реального времени) подстраивается под размер вашего устройства, и если размер дисплея вдруг расширится / сузится (как при ресайзе браузера или смене ориентации планшета), то и сайт на это отреагирует незамедлительно, без перезагрузок и задержек.
            В итоге мы получаем одну единственную версию сайта (site-on.net), которая великолепно отображается на любых устройствах и экранах, учитывая их особенности.
            На создание адаптивного макета этого блога (из фиксированного) у меня ушла вся прошлая суббота: с 9:00 утра до полуночи с перерывами на отдых.
            Это занятие показалось мне слегка нудным, но желание насладиться конечным результатом не давало угаснуть энтузиазму.
            Теперь у всех посетителей этого блога появилась возможность удобного чтения статей с любого устройства: начиная с магнитолы в вашем авто и заканчивая телевизором на вашей стене.
            Ради идеи пришлось даже распрощаться с рекламной строкой nolix, так как она была не уместна при маленьких разрешениях экранов, а убрать ее специально для них было бы обманом рекламодателей, ведь показы, скорее всего, все равно бы накручивались.
            Приступим!"
        );
        $blog2->setImage('one.jpg');
        $blog2->setAuthor('Роман Наконечний');
        $blog2->setTags('blog, html, css, адаптив');
        $manager->persist($blog2);

        $blog3 = new Blog();
        $blog3->setTitle('Разработка сайтов на PrestaShop');
        $blog3->setBlog('
            Как видно из заголовка, речь в данной статье пойдет о разработке сайтов-магазинов. Сразу хочу оговориться: данный пост не является техническим, это, скорее, просто выжимка из собственного опыта работы с e-commerce платформами. Основной целью при написании текста было желание поделиться своим опытом с разработчиками, только начинающими свой путь в огромном мире девелопмента для e-commerce.
            Красной линией в этом тексте будет проходить вопрос выбора платформы для вашего будущего магазина.
            Случилось так, что свою карьеру разработчика я начал в компании, основной специализацией которой были интернет-магазины. С того времени и по сей день я в поиске идеальной СMS под это дело. На данный момент движков для построения своего магазина существует превеликое множество, от древних и морально устаревших, как-то Ubercart или Opencart, до современных гигантов вроде Magento, но как говорится, истина где-то между... В данный момент золотой серединой для меня является СMS Prestashop.
            Интернет хранит неисчислимое множество сравнений по производительности, проценту покрытия рынка и прочих параметрах, но это сухая статистика, в ней жизни нету :). Гораздо интереснее то, почему использует тот или иной движок конкретный разработчик.
            Отправной точкой в моем нелегком путешествий стала упомянутая выше СMS Magento, но так как на тот момент я был зеленым джуном, система показалась мне слишком тяжелой: все эти бесконечные xml-файлы конфигураций (похоже на то, что разработчикам системы за их количество доплачивали :) ); к тому же, движок довольно «тугой» в плане производительности, без varnish на prod ни ногой. Кто-то может возразить, «да ну, вы просто не умеете его готовить». Возможно, в этом есть доля истины, но с тем фактом, что система весьма сложная для освоения, думаю, многие согласятся (вспомнить одни формочки в админке, сразу мутить начинает).');
        $blog3->setImage('three.jpg');
        $blog3->setAuthor('Євгеній Жолкевський');
        $blog3->setTags('blog, php, prestashop, CMS');
        $manager->persist($blog3);

        $blog4 = new Blog();
        $blog4->setTitle('Symfony2 Vs Yii: какой фреймворк выбрать в 2015-м году?');
        $blog4->setBlog('
            Symfony — это PHP-фреймворк для веб-проектов или, иными словами, набор PHP-компонентов, Symfony2 создан на стандартной основе, на которой разработаны большинство лучших PHP-приложений. С другой стороны, Yii (сокращение для «Yes It Is») — это компонентный PHP-фреймворк, используемый для разработки крупномасштабных веб-приложений. Фреймворк известен оптимизацией под повторное использование в веб-программировании и может ускорить процесс разработки. И, хоть оба они и являются фреймворками для разработки на PHP, между ними есть существенные различия, о которых мы и поговорим в этой статье. Если честно, мы пользовались и тем, и другим, и эта парочка вызывает у нас теплые чувства. Однако мы постепенно перешли на Symfony2, и этому найдется несколько причин.
            Разница, она, знаете ли, в деталях :-). Ну что, готовы кабанчиком пробежаться по двум самым часто используемым MVC-фреймворкам, Yii и Symfony2?! Тогда мы начинаем.
            Производительность Symfony2 vs Yii: краткое сравнение
            Прежде, чем мы погрузимся в повседневные аспекты производительности Symfony2 и Yii, рассмотрим основные возможности и особенности использования этих двух фреймворков. В качестве ORM Yii использует Active Record ORM, который был непосредственно вдохновлен тем Active Record, что в Ruby on Rails. С другой стороны, Symfony2 использует Doctrine2. Doctrine2 сама по себе имеет целый набор фич для PHP-разработчиков. Как? Ну, сущности Doctrine2 — это простые PHP-классы. Метаданные отображены в аннотациях сущностей. Управление базами данных для Doctrine2 не представляет проблемы. Многие разработчики считают, что Yii гораздо проще использовать в проектах, чем Symfony2. Тем не менее, целые толпы разработчиков рекомендуют Symfony2 за простую реализацию фикстур и миграций, что характерно для Doctrine2.
            Однако это далеко не все..'
        );
        $blog4->setImage('four.jpg');
        $blog4->setAuthor('Євгеній Жолкевський');
        $blog4->setTags('blog, symfony, yii, php');
        $manager->persist($blog4);

        $manager->flush();

        $this->addReference('blog-1', $blog1);
        $this->addReference('blog-2', $blog2);
        $this->addReference('blog-3', $blog3);
        $this->addReference('blog-4', $blog4);
    }

    public function getOrder()
    {
        return 1;
    }
}